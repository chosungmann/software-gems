#ifndef PLBM_H
#define PLBM_H
/*----------------------------------------------------------------------*/
/* PLBM.H  typedefs for PLane-oriented BitMap.			8/31/85 */
/*----------------------------------------------------------------------*/
#include "exec/types.h"
#include "packer.h"

typedef enum {cmpNone = 0, cmpByteRun1 = 1} _Compression;
typedef UBYTE Compression;
    /* Choice of compression algorithm. "cmpByteRun1" is the byte run
     * encoding generated by Mac's PackBits. See Packer.h . */


/* ---------- ID, Chunk, FORM ------------------------------------------*/

typedef char _ID[4];	/* An identifier is four printable ASCII chars.*/
typedef LONG ID;	/* but stored as a long, so can copy, compare,
			 * as a whole value.*/

/* All chunks start with a type id and a count of the data bytes that 
   follow.  That is, the "valid" data bytes; if that number is odd,
   the number of bytes written is incremented using WordAlign(size).  */
typedef struct {
    ID	  ckID;
    LONG  ckSize;
    } ChunkHeader;

typedef struct {
    ID	  ckID;
    LONG  ckSize;
    UBYTE ckData[ 1 /*ckSize*/ ];
    } Chunk;

/* ALL CHUNKS MUST BE PADDED TO EVEN NUMBER OF BYTES */
#define WordAlign(size)   ((size+1)&~1)

/* The Grouping chunks (LIST,FORM,PROP) guarantee that their bodies 
   are a concatenation of chunks.  They all have a SubType ID to further 
   identify their contents.  "LIST of chunks of type XXXX", "FORM XXXX", 
   "PROPerties associated with chunks of type XXXX".*/
typedef struct {
    ID	  ckID;
    LONG  ckSize;
    ID    grpSubID;
    } GroupHeader;

typedef struct {
    ID	  ckID;
    LONG  ckSize;
    ID    grpSubID;
    UBYTE grpData[ 1 /*ckSize-4*/ ];
    } GroupChunk;

#define FORM SToLong("FORM")
#define PLBM SToLong("PLBM")
#define BMHD SToLong("BMHD")
#define CMAP SToLong("CMAP")
#define BITP SToLong("BITP")

/* ---------- BitMapHeader ---------------------------------------------*/

typedef enum {mskNone = 0, mskHasMask = 1, mskHasTransparentColor = 2}
    _Masking;
typedef UBYTE Masking;	/* Lattice makes enum's LONG.  what a crock.*/
    /* Choice of masking technique.*/

typedef enum {pix320x200 = 0, pix640x200 = 1, pix320x400 = 2, pix640x400 = 3,
    pixMacintosh = 4} _PixelFormat;
typedef UBYTE PixelFormat;
    /* Pixel size & aspect.  The first four are common television &
       RGB resolutions.  "pixMacintosh" means 72 pixels per inch (square). */
    /* (We'll have to assign values to formats used by other cpus).*/

typedef struct {
    UWORD rowWords;		/* # words in an uncompressed row */
    UWORD w, h;			/* raster width & height in pixels */
    UBYTE depth;		/* # destination bitplanes */
    UBYTE nPlanes;		/* # source bitplanes (BITP chunks) */
    Masking masking;		/* masking technique */
    PixelFormat pixelFormat;		/* pixel size and aspect */
    Compression compression;
    UBYTE pad1;			/* UNUSED.  For consistency, put 0 here.*/
    UWORD transparentColor;	/* transparent "color number" */
    } BitMapHeader;

/* ---------- SavePLBM -------------------------------------------------*/

/* Save a whole screen as a PLBM.  Later, modify to take a BitMap.
   This hack is to get Greg going. Returns TRUE if error. */
extern BOOL SavePLBM(char *, APTR, PixelFormat, WORD *, LONG);
	           /* name, screen,   mode,   colorMap, # planes */

extern BOOL LoadPLBM(char *, struct ViewPort *, APTR,
		     PixelFormat *, WORD *, LONG *);
		   /* name, viewPort, screen,
		      ptr to mode, colorMap, ptr to #planes */
		/* Writes to all parameters except name.*/

#endif
